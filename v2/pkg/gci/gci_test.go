package gci

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/daixiang0/gci/v2/pkg/config"
	"github.com/daixiang0/gci/v2/pkg/parse"
	"github.com/daixiang0/gci/v2/pkg/section"
)

func TestRun(t *testing.T) {
	for i := range testCases {
		t.Run(fmt.Sprintf("run case: %s", testCases[i].name), func(t *testing.T) {
			cfg, err := config.ParseConfig(testCases[i].config)
			if err != nil {
				t.Fatal(err)
			}

			old, new, err := LoadFormat([]byte(testCases[i].in), "", *cfg)
			if err != nil {
				t.Fatal(err)
			}

			if string(old) != testCases[i].in {
				t.Errorf("input mismatch:\ngot:\n%s\nwant:\n%s", string(old), testCases[i].in)
			}
			if string(new) != testCases[i].out {
				t.Errorf("output mismatch:\ngot:\n%s\nwant:\n%s", string(new), testCases[i].out)
			}
		})
	}
}

func chdir(t *testing.T, dir string) {
	oldWd, err := os.Getwd()
	if err != nil {
		t.Fatal(err)
	}
	if err := os.Chdir(dir); err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() { os.Chdir(oldWd) })
}

func readConfig(t *testing.T, configPath string) *config.Config {
	rawConfig, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatal(err)
	}
	cfg, err := config.ParseConfig(string(rawConfig))
	if err != nil {
		t.Fatal(err)
	}

	return cfg
}

func TestRunWithLocalModule(t *testing.T) {
	tests := []struct {
		name      string
		moduleDir string
		testedFiles []string
	}{
		{
			name:      `default module test case`,
			moduleDir: filepath.Join("testdata", "module"),
			testedFiles: []string{
				"main.go",
				filepath.Join("internal", "foo", "lib.go"),
			},
		},
		{
			name:      `canonical module without go sources in root dir`,
			moduleDir: filepath.Join("testdata", "module_canonical"),
			testedFiles: []string{
				filepath.Join("cmd", "client", "main.go"),
				filepath.Join("cmd", "server", "main.go"),
				filepath.Join("internal", "foo", "lib.go"),
			},
		},
		{
			name:      `non-canonical module without go sources in root dir`,
			moduleDir: filepath.Join("testdata", "module_noncanonical"),
			testedFiles: []string{
				filepath.Join("cmd", "client", "main.go"),
				filepath.Join("cmd", "server", "main.go"),
				filepath.Join("internal", "foo", "lib.go"),
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			chdir(t, tt.moduleDir)
			cfg := readConfig(t, "config.yaml")

			for _, path := range tt.testedFiles {
				t.Run(path, func(t *testing.T) {
					expected, err := os.ReadFile(strings.TrimSuffix(path, ".go") + ".out.go")
					if err != nil {
						t.Fatal(err)
					}

					fileObj := FileObj{
						Path: path,
						Load: func() ([]byte, error) {
							return os.ReadFile(path)
						},
					}
					_, got, err := LoadFormatGoFile(fileObj, *cfg)

					if err != nil {
						t.Fatal(err)
					}
					if string(expected) != string(got) {
						t.Errorf("output mismatch:\ngot:\n%s\nwant:\n%s", string(got), string(expected))
					}
				})
			}
		})
	}
}

func TestRunWithLocalModuleWithPackageLoadFailure(t *testing.T) {
	dir := t.TempDir()
	configContent := "sections:\n  - LocalModule\n"

	chdir(t, dir)
	_, err := config.ParseConfig(configContent)
	if err == nil {
		t.Fatal("expected error for missing go.mod")
	}
	if !strings.Contains(err.Error(), "go.mod") {
		t.Fatalf("expected error to contain 'go.mod', got: %v", err)
	}
}

func TestNoImportError(t *testing.T) {
	src := `package main

func main() {}
`
	_, _, _, _, _, err := parse.ParseFile([]byte(src), "test.go")
	if err == nil {
		t.Fatal("expected NoImportError")
	}
	if _, ok := err.(parse.NoImportError); !ok {
		t.Fatalf("expected NoImportError, got: %T", err)
	}
}

func TestSkipGeneratedFile(t *testing.T) {
	src := `// Code generated by tool. DO NOT EDIT.
package main

import (
	"fmt"
	"os"
)

func main() {}
`
	cfg := config.Config{
		BoolConfig: config.BoolConfig{
			SkipGenerated: true,
		},
		Sections: section.DefaultSections(),
	}

	old, new, err := LoadFormat([]byte(src), "test.go", cfg)
	if err != nil {
		t.Fatal(err)
	}

	if string(old) != string(new) {
		t.Error("expected generated file to be skipped")
	}
}
