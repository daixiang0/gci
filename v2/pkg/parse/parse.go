package parse

import (
	"go/ast"
	"go/parser"
	"go/token"
	"sort"
	"strings"
)

const C = "\"C\""

type GciImports struct {
	Start, End int
	Name, Path string
}

type ImportList []*GciImports

func (l ImportList) Len() int {
	return len(l)
}

func (l ImportList) Less(i, j int) bool {
	if strings.Compare(l[i].Path, l[j].Path) == 0 {
		return strings.Compare(l[i].Name, l[j].Name) < 0
	}

	return strings.Compare(l[i].Path, l[j].Path) < 0
}

func (l ImportList) Swap(i, j int) { l[i], l[j] = l[j], l[i] }

func getImports(imp *ast.ImportSpec) (start, end int, name string) {
	if imp.Doc != nil {
		start = int(imp.Doc.Pos()) - 1
	} else {
		if imp.Name != nil {
			start = int(imp.Name.Pos()) - 1
		} else {
			start = int(imp.Path.Pos()) - 1
		}
	}

	if imp.Name != nil {
		name = imp.Name.Name
	}

	if imp.Comment != nil {
		end = int(imp.Comment.End())
	} else {
		end = int(imp.Path.End())
	}
	return
}

func ParseFile(src []byte, filename string) (ImportList, int, int, int, int, error) {
	fileSet := token.NewFileSet()
	f, err := parser.ParseFile(fileSet, filename, src, parser.ParseComments)
	if err != nil {
		return nil, 0, 0, 0, 0, err
	}

	if len(f.Imports) == 0 {
		return nil, 0, 0, 0, 0, NoImportError{}
	}

	var (
		headEnd   int
		tailStart int
		cStart    int
		cEnd      int
		data      ImportList
	)

	for index, decl := range f.Decls {
		switch decl.(type) {
		case *ast.GenDecl:
			genDecl := decl.(*ast.GenDecl)

			if genDecl.Tok == token.IMPORT {
				if headEnd == 0 {
					headEnd = int(decl.Pos()) - 1
				}
				tailStart = int(decl.End())
				if tailStart > len(src) {
					tailStart = len(src)
				}

				for _, spec := range genDecl.Specs {
					imp := spec.(*ast.ImportSpec)
					if imp.Path.Value == C {
						if genDecl.Doc != nil {
							cStart = int(genDecl.Doc.Pos()) - 1
							if index == 0 {
								headEnd = cStart
							}
						} else {
							cStart = int(decl.Pos()) - 1
						}

						cEnd = int(decl.End())

						continue
					}

					start, end, name := getImports(imp)

					data = append(data, &GciImports{
						Start: start,
						End:   end,
						Name:  name,
						Path:  strings.Trim(imp.Path.Value, `"`),
					})
				}
			}
		}
	}

	sort.Sort(data)
	return data, headEnd, tailStart, cStart, cEnd, nil
}

func IsGeneratedFileByComment(in string) bool {
	const (
		genCodeGenerated = "code generated"
		genDoNotEdit     = "do not edit"
		genAutoFile      = "autogenerated file"
		genAutoGenerated = "automatically generated"
	)

	markers := []string{genCodeGenerated, genDoNotEdit, genAutoFile, genAutoGenerated}
	in = strings.ToLower(in)
	for _, marker := range markers {
		if strings.Contains(in, marker) {
			return true
		}
	}

	return false
}

type NoImportError struct{}

func (n NoImportError) Error() string {
	return "No imports"
}

func (i NoImportError) Is(err error) bool {
	_, ok := err.(NoImportError)
	return ok
}
